package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, UNION, DO, WHILE, MAP, INTERFACE, PLUS, MINUS, MUL, DIV, MOD, EQEQ, NOTEQ, GR, GREQ, LE, LEQ, AND, OR, EQ, INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, MAIN ;
terminal Integer NUMBER, BOOL ;
terminal String IDENT ;
terminal Character CHAR ;

nonterminal MethodSignatureEndFormPars, MethodSignatureStartFormPars, ConstDeclAssign, Setop, Mulop, Addop, Relop, Assignop, Label, ProgramDeclList, ProgramDeclElem, ConstDecl, ConstDeclList, VarDecl, VarDeclOptionalList, VarDeclListOptional, MethodSignature, TypeChoice, FormParsOptional, FormPars, MethodDecl, VarDeclList, MethodDeclList, StatementList, Statement, DesignatorStatement;
nonterminal ActPars, DesignatorFuncCall, DesignatorStatementUnary, StackInitialize, MapDesignator, ClassMethodDeclListStart;
nonterminal Program, InterfaceDeclOptionList, VarDeclProgram, VarDeclErrorComma, VarDeclErrorSemi, DesignatorAssign, VarDeclClass, ClassDeclErrorLBrace, DesignatorAssignWhile, DesignatorStatementWhile, DoStatement ;
nonterminal SetClassFieldAddress, CloseMethodScope, Else, WhileStatement, HandleWhileCondition, GoToStart;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr, CondFact, CondTerm, Condition, StatementCondition, Type, ClassDeclName, ExtendsClass, ClassDecl, InterfaceDeclName, InterfaceDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ConstDeclListValue, Designator, DesignatorArrayName, DesignatorClassMore, DesignatorClassArrayName, DesignatorClassName, DesignatorClassElem, VarDeclFinal;

nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodName;

precedence left ELSE;

Program ::= (Program)  PROG ProgName ProgramDeclList LBRACE MethodDeclList RBRACE ;

ProgName ::= (ProgName) IDENT:progName;

ProgramDeclList ::= ProgramDeclList ProgramDeclElem
                    |
                    /* epsilon */
                    ;

ProgramDeclElem ::= ConstDecl
                    |
                    VarDeclProgram
                    |
                    ClassDecl
                    |
                    InterfaceDecl
                    ;

VarDeclProgram ::= VarDeclErrorSemi
                   |
                   VarDeclErrorComma VarDeclFinal VarDeclOptionalList SEMI
                   |
                   VarDecl
                   ;

VarDeclErrorComma ::= error COMMA:l
                      {: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null); :}
                      ;

VarDeclErrorSemi ::= error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
                     ;

ConstDecl ::= CONST Type ConstDeclList SEMI ;

ConstDeclListValue ::= (NumConst)NUMBER
                       |
                       (CharConst)CHAR
                       |
                       (BoolConst)BOOL
                       ;

ConstDeclList ::= ConstDeclList COMMA ConstDeclAssign
                          |
                          ConstDeclAssign
                          ;

ConstDeclAssign ::= (ConstDeclAssign)IDENT EQ ConstDeclListValue ;

VarDecl ::= Type VarDeclFinal VarDeclOptionalList SEMI
            ;

VarDeclFinal ::= (VarDeclFinalArray)IDENT LBRACKET RBRACKET
                 |
                 (VarDeclFinalVar)IDENT
                 ;

VarDeclOptionalList ::= VarDeclOptionalList COMMA VarDeclFinal
                        |
                        /* epsilon */
                        ;

InterfaceDecl ::= (InterfaceDecl) INTERFACE InterfaceDeclName LBRACE InterfaceDeclOptionList RBRACE
                  ;

InterfaceDeclName ::= (InterfaceDeclName) IDENT ;

InterfaceDeclOptionList ::= InterfaceDeclOptionList MethodDecl
                            |
                            InterfaceDeclOptionList MethodSignature CloseMethodScope SEMI
                            |
                            /* epsilon */
                            ;

CloseMethodScope ::= (CloseMethodScope) /* epsilon */ ;

ClassDecl ::= (ClassNoExtend) CLASS ClassDeclName LBRACE VarDeclListOptional SetClassFieldAddress RBRACE
              |
              (ClassYesExtend) CLASS ClassDeclName ExtendsClass LBRACE VarDeclListOptional SetClassFieldAddress RBRACE
              |
              CLASS ClassDeclName EXTENDS ClassDeclErrorLBrace VarDeclListOptional RBRACE /* error */
              |
              (ClassNoExtendYesMethods) CLASS ClassDeclName LBRACE VarDeclListOptional SetClassFieldAddress LBRACE ClassMethodDeclListStart MethodDeclList RBRACE RBRACE
              |
              (ClassYesExtendYesMethods) CLASS ClassDeclName ExtendsClass LBRACE VarDeclListOptional SetClassFieldAddress LBRACE ClassMethodDeclListStart MethodDeclList RBRACE RBRACE
              |
              CLASS ClassDeclName EXTENDS ClassDeclErrorLBrace VarDeclListOptional LBRACE ClassMethodDeclListStart MethodDeclList RBRACE RBRACE /* error */
              |
              CLASS ClassDeclName LBRACE VarDeclListOptional ClassDeclErrorLBrace ClassMethodDeclListStart MethodDeclList RBRACE RBRACE /* error */
              |
              CLASS ClassDeclName ExtendsClass LBRACE VarDeclListOptional ClassDeclErrorLBrace ClassMethodDeclListStart MethodDeclList RBRACE RBRACE /* error */
              |
              CLASS ClassDeclName EXTENDS ClassDeclErrorLBrace VarDeclListOptional ClassDeclErrorLBrace ClassMethodDeclListStart MethodDeclList RBRACE RBRACE /* error */
              ;

SetClassFieldAddress ::= (SetClassFieldAddress) /* epsilon */ ;

ExtendsClass ::= (ExtendsClass) EXTENDS Type ;

ClassMethodDeclListStart ::= (ClassMethodDeclListStart) /* epsilon */ ;

ClassDeclName ::= (ClassDeclName) IDENT;

VarDeclListOptional ::= VarDeclListOptional VarDeclClass
                        |
                        /* epsilon */
                        ;

ClassDeclErrorLBrace ::= error LBRACE:l
                         {: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null); :}
                         ;

VarDeclClass ::= VarDecl
                 |
                 error SEMI:l
                 {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
                 ;

MethodDeclList ::= MethodDeclList MethodDecl
                   |
                   /* epsilon */
                   ;

MethodSignature ::= TypeChoice MethodName MethodSignatureStartFormPars FormParsOptional
                    ;

MethodSignatureStartFormPars ::= (MethodSignatureStartFormPars)LPAREN ;

MethodSignatureEndFormPars ::= (MethodSignatureEndFormPars)RPAREN ;

MethodName ::= (RegularMethod)IDENT
               |
               (MainMethod)MAIN
               ;

TypeChoice ::= (NoVoidMethod)IDENT
               |
               (VoidMethod)VOID
               ;

FormParsOptional ::=  FormPars
                      |
                      MethodSignatureEndFormPars /* epsilon */
                      ;

MethodDecl ::= (MethodDecl)MethodSignature VarDeclList LBRACE StatementList RBRACE
               ;

VarDeclList ::= VarDeclList VarDecl
                |
                /* epsilon */
                ;

FormPars ::= Type VarDeclFinal MethodSignatureEndFormPars
             |
             error MethodSignatureEndFormPars:l
             {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :}
             |
             Type VarDeclFinal COMMA FormPars
             |
             VarDeclErrorComma FormPars
             ;

Type ::= (TypeIdent) IDENT
         ;

StatementList ::= StatementList Statement
                  |
                  /* epsilon */
                  ;

Statement ::=   DesignatorStatement
              |
              (StatementElse) IF LPAREN StatementCondition Statement Else Statement
              |
              (StatementNoElse) IF LPAREN StatementCondition Statement
              |
              (StatementBreak) BREAK SEMI
              |
              (StatementContinue) CONTINUE SEMI
              |
              (StatementReturn) RETURN SEMI
              |
              (StatementReturnExpr) RETURN Expr SEMI
              |
              (StatementRead) READ LPAREN Designator RPAREN SEMI
              |
              (StatementPrint) PRINT LPAREN Expr RPAREN SEMI
              |
              (StatementPrintNumber) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
              |
              (StatementLoopSimple) DoStatement Statement WhileStatement LPAREN RPAREN GoToStart SEMI
              |
              (StatementLoopCondition) DoStatement Statement WhileStatement LPAREN Condition HandleWhileCondition RPAREN GoToStart SEMI
              |
              (StatementLoopComplex) DoStatement Statement WhileStatement LPAREN Condition COMMA HandleWhileCondition DesignatorStatementWhile RPAREN GoToStart SEMI
              |
              LBRACE StatementList RBRACE
              ;

Else ::= (Else) ELSE ;

DoStatement ::= (DoStatement) DO;

WhileStatement ::= (WhileStatement) WHILE;

HandleWhileCondition ::= (HandleWhileCondition) /* epsilon */ ;

GoToStart ::= (GoToStart) /* epsilon */ ;


DesignatorStatementWhile ::= (DesignatorStatementFuncCallWhile)Designator DesignatorFuncCall
                             |
                             (DesignatorStatementUnarySemiWhile) Designator DesignatorStatementUnary
                             |
                             DesignatorAssignWhile
                             ;

DesignatorAssignWhile ::= (DesignatorAssignExprWhile) Designator Assignop Expr
                          |
                          (DesignatorAssignSetopWhile) Designator Assignop Designator Setop Designator
                          ;

StatementCondition ::= (StatementConditionCondition) Condition RPAREN
                       |
                       error RPAREN:l
                       {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :}
                       ;


DesignatorStatement ::= (DesignatorStatementUnarySemi) Designator DesignatorStatementUnary SEMI
                        |
                        (DesignatorStatementFuncCall) Designator DesignatorFuncCall SEMI
                        |
                        DesignatorAssign
                        ;

DesignatorAssign ::= (DesignatorAssignExpr) Designator Assignop Expr SEMI
                     |
                     (DesignatorAssignSetop) Designator Assignop Designator Setop Designator SEMI
                     |
                     error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
                     ;

DesignatorStatementUnary ::= (UnaryInc) INC
                             |
                             (UnaryDec) DEC
                             ;

Designator ::= (DesignatorVar) IDENT
               |
               (DesignatorPropertyAccess) DesignatorClassName DesignatorClassMore
               |
               (DesignatorElem) DesignatorArrayName LBRACKET Expr RBRACKET
               |
               (DesignatorElemPropertyAccess) DesignatorClassElem DesignatorClassMore
               ;

DesignatorClassMore ::= (DesignatorClassMoreFinal) DOT IDENT
                        |
                        (DesignatorClassMoreFinalElem) DOT DesignatorClassArrayName LBRACKET Expr RBRACKET
                        |
                        (DesignatorClassMoreNotFinal) DesignatorClassMore DOT IDENT
                        |
                        (DesignatorClassMoreNotFinalElem) DesignatorClassMore DOT DesignatorClassArrayName LBRACKET Expr RBRACKET
                        ;

DesignatorClassElem ::= (DesignatorClassElem) DesignatorArrayName LBRACKET Expr RBRACKET ;
DesignatorClassName ::= (DesignatorClassName) IDENT;
DesignatorClassArrayName ::= (DesignatorClassArrayName) IDENT;
DesignatorArrayName ::= (DesignatorArrayName) IDENT;

ActPars ::= (ActParsMultipleItems) Expr COMMA ActPars
            |
            (ActParsSigleItem) Expr
            ;

Condition ::= (ConditionOr) Condition OR CondTerm
              |
              (ConditionCondTerm) CondTerm
              ;

CondTerm ::= (CondTermAnd) CondFact AND CondTerm
             |
             (CondTermCondFact) CondFact
             ;

CondFact ::= (CondFactRelop) Expr Relop Expr
             |
             (CondFactExpr) Expr
             ;

Expr ::= (ExprTerm) Term
         |
         (ExprMinusTerm) MINUS Term
         |
         (ExprAddopTerm) Expr Addop Term
         |
         (ExprDesignatorMap) Designator MapDesignator
         ;

MapDesignator ::= (MapDesignator) MAP Designator
                  ;

Term ::= (TermFactor) Factor
         |
         (TermTermMulopFactor) Term Mulop Factor
         ;

Factor ::= (FactorDesignator) Designator
           |
           (FactorFuncCall)Designator DesignatorFuncCall
           |
           (FactorConstDeclListValue) ConstDeclListValue
           |
           (FactorCreateArray) NEW Type LBRACKET Expr RBRACKET
           |
           (FactorCreateObject) NEW Type DesignatorFuncCall
           |
           (FactorExpr) LPAREN Expr RPAREN
           ;

DesignatorFuncCall ::= LPAREN StackInitialize RPAREN
                   |
                   LPAREN StackInitialize ActPars RPAREN
                   ;

StackInitialize ::= (StackInitialize) /* epsilon */;

Label ::= IDENT ;

Assignop ::= EQ ;

Relop ::= (RelopEqual) EQEQ | (RelopNotEqual) NOTEQ | (RelopGreaterThan) GR | (RelopGreaterThanOrEqual) GREQ | (RelopLessThan) LE | (RelopLessThanOrEqual) LEQ ;

Addop ::= (AddopPlus)PLUS | (AddopMinus)MINUS ;

Mulop ::= (MulopMul)MUL | (MulopDiv)DIV | (MulopMod)MOD ;

Setop ::= UNION ;