package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, SET, UNION, DO, WHILE, MAP, INTERFACE, PLUS, MINUS, MUL, DIV, MOD, EQEQ, NOTEQ, GR, GREQ, LE, LEQ, AND, OR, EQ, INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, MAIN ;
terminal Integer NUMBER, BOOL ;
terminal String IDENT ;
terminal Character CHAR ;

nonterminal Type, MethodSignatureEndFormPars, MethodSignatureStartFormPars, MethodName, ConstDeclAssign, Setop, Mulop, Addop, Relop, Assignop, Label, ProgramDeclList, ProgramDeclElem, ConstDecl, ConstDeclList, VarDecl, VarDeclFinal, VarDeclOptionalList, ClassDecl, VarDeclListOptional, MethodSignature, TypeChoice, FormParsOptional, FormPars, MethodDecl, VarDeclList, MethodDeclList, MathodDecl, StatementList, Statement, DesignatorStatement;
nonterminal ActPars, DesignatorFuncCall, MapDesignator, DesignatorStatementUnary, CondFact, CondTerm, Condition;
nonterminal Program, InterfaceDeclOptionList, InterfaceDecl, VarDeclProgram, VarDeclErrorComma, VarDeclErrorSemi, DesignatorAssign, StatementCondition, VarDeclClass, ClassDeclErrorLBrace, DesignatorAssignWhile, DesignatorStatementWhile, DoStatement ;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ConstDeclListValue, Designator, DesignatorArrayName;

precedence left ELSE;

Program ::= (Program)  PROG ProgName ProgramDeclList LBRACE MethodDeclList RBRACE ;

ProgName ::= (ProgName) IDENT:progName;

ProgramDeclList ::= ProgramDeclList ProgramDeclElem
                    |
                    /* epsilon */
                    ;

ProgramDeclElem ::= ConstDecl
                    |
                    VarDeclProgram
                    |
                    ClassDecl
                    |
                    InterfaceDecl
                    ;

VarDeclProgram ::= VarDeclErrorSemi
                   |
                   VarDeclErrorComma VarDeclFinal VarDeclOptionalList SEMI
                   |
                   VarDecl
                   ;

VarDeclErrorComma ::= error COMMA:l
                      {: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null); :}
                      ;

VarDeclErrorSemi ::= error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
                     ;

ConstDecl ::= CONST Type ConstDeclList SEMI ;

ConstDeclListValue ::= (NumConst)NUMBER
                       |
                       (CharConst)CHAR
                       |
                       (BoolConst)BOOL
                       ;

ConstDeclList ::= ConstDeclList COMMA ConstDeclAssign
                          |
                          ConstDeclAssign
                          ;

ConstDeclAssign ::= (ConstDeclAssign)IDENT EQ ConstDeclListValue ;

VarDecl ::= Type VarDeclFinal VarDeclOptionalList SEMI
            ;

VarDeclFinal ::= (VarDeclFinalArray)IDENT LBRACKET RBRACKET
                 |
                 (VarDeclFinalVar)IDENT
                 ;

VarDeclOptionalList ::= VarDeclOptionalList COMMA VarDeclFinal
                        |
                        /* epsilon */
                        ;

InterfaceDecl ::= INTERFACE IDENT LBRACE InterfaceDeclOptionList RBRACE
                  ;

InterfaceDeclOptionList ::= InterfaceDeclOptionList MethodDecl
                            |
                            InterfaceDeclOptionList MethodSignature SEMI
                            |
                            /* epsilon */
                            ;

ClassDecl ::= CLASS IDENT LBRACE VarDeclListOptional RBRACE
              |
              CLASS IDENT EXTENDS Type LBRACE VarDeclListOptional RBRACE
              |
              CLASS IDENT EXTENDS ClassDeclErrorLBrace VarDeclListOptional RBRACE
              |
              CLASS IDENT LBRACE VarDeclListOptional LBRACE MethodDeclList RBRACE RBRACE
              |
              CLASS IDENT EXTENDS Type LBRACE VarDeclListOptional LBRACE MethodDeclList RBRACE RBRACE
              |
              CLASS IDENT EXTENDS ClassDeclErrorLBrace VarDeclListOptional LBRACE MethodDeclList RBRACE RBRACE
              |
              CLASS IDENT LBRACE VarDeclListOptional ClassDeclErrorLBrace MethodDeclList RBRACE RBRACE
              |
              CLASS IDENT EXTENDS Type LBRACE VarDeclListOptional ClassDeclErrorLBrace MethodDeclList RBRACE RBRACE
              |
              CLASS IDENT EXTENDS ClassDeclErrorLBrace VarDeclListOptional ClassDeclErrorLBrace MethodDeclList RBRACE RBRACE
              ;

VarDeclListOptional ::= VarDeclListOptional VarDeclClass
                        |
                        /* epsilon */
                        ;

ClassDeclErrorLBrace ::= error LBRACE:l
                         {: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null); :}
                         ;

VarDeclClass ::= Type IDENT VarDeclFinal VarDeclOptionalList SEMI
                 |
                 error SEMI:l
                 {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
                 ;

MethodDeclList ::= MethodDeclList MethodDecl
                   |
                   /* epsilon */
                   ;

MethodSignature ::= TypeChoice MethodName MethodSignatureStartFormPars FormParsOptional
                    ;

MethodSignatureStartFormPars ::= (MethodSignatureStartFormPars)LPAREN ;

MethodSignatureEndFormPars ::= (MethodSignatureEndFormPars)RPAREN ;

MethodName ::= (RegularMethod)IDENT
               |
               (MainMethod)MAIN
               ;

TypeChoice ::= (NoVoidMethod)IDENT
               |
               (VoidMethod)VOID
               ;

FormParsOptional ::=  FormPars
                      |
                      MethodSignatureEndFormPars /* epsilon */
                      ;

MethodDecl ::= (MethodDecl)MethodSignature VarDeclList LBRACE StatementList RBRACE
               ;

VarDeclList ::= VarDeclList VarDecl
                |
                /* epsilon */
                ;

FormPars ::= Type VarDeclFinal MethodSignatureEndFormPars
             |
             error MethodSignatureEndFormPars:l
             {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :}
             |
             Type VarDeclFinal COMMA FormPars
             |
             VarDeclErrorComma FormPars
             ;

Type ::= (TypeIdent) IDENT
         |
         (TypeSet) SET
         ;

StatementList ::= StatementList Statement
                  |
                  /* epsilon */
                  ;

Statement ::=   DesignatorStatement
              |
              IF LPAREN StatementCondition Statement ELSE Statement
              |
              IF LPAREN StatementCondition Statement
              |
              (StatementBreak) BREAK SEMI
              |
              (StatementContinue) CONTINUE SEMI
              |
              (StatementReturn) RETURN SEMI
              |
              (StatementReturnExpr) RETURN Expr SEMI
              |
              (StatementRead) READ LPAREN Designator RPAREN SEMI
              |
              (StatementPrint) PRINT LPAREN Expr RPAREN SEMI
              |
              (StatementPrintNumber) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
              |
              (StatementLoopSimple) DoStatement Statement WHILE LPAREN RPAREN SEMI
              |
              (StatementLoopCondition) DoStatement Statement WHILE LPAREN Condition RPAREN SEMI
              |
              (StatementLoopComplex) DoStatement Statement WHILE LPAREN Condition COMMA DesignatorStatementWhile RPAREN SEMI
              |
              LBRACE StatementList RBRACE
              ;

DoStatement ::= (DoStatement) DO;

DesignatorStatementWhile ::= (DesignatorStatementFuncCallWhile)Designator DesignatorFuncCall
                             |
                             (DesignatorStatementUnarySemiWhile) Designator DesignatorStatementUnary
                             |
                             DesignatorAssignWhile
                             ;

DesignatorAssignWhile ::= (DesignatorAssignExprWhile) Designator Assignop Expr
                          |
                          Designator Assignop Designator Setop Designator
                          ;

StatementCondition ::= Condition RPAREN
                       |
                       error RPAREN:l
                       {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :}
                       ;


DesignatorStatement ::= (DesignatorStatementUnarySemi) Designator DesignatorStatementUnary SEMI
                        |
                        (DesignatorStatementFuncCall) Designator DesignatorFuncCall SEMI
                        |
                        DesignatorAssign
                        ;

DesignatorAssign ::= (DesignatorAssignExpr) Designator Assignop Expr SEMI
                     |
                     Designator Assignop Designator Setop Designator SEMI
                     |
                     error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
                     ;

DesignatorStatementUnary ::= INC
                              |
                              DEC
                              ;

Designator ::= (DesignatorVar) IDENT
               |
               IDENT DOT IDENT
               |
               (DesignatorElem) DesignatorArrayName LBRACKET Expr RBRACKET
               ;

DesignatorArrayName ::= (DesignatorArrayName) IDENT;

ActPars ::= Expr COMMA ActPars
            |
            Expr
            ;

Condition ::= CondTerm OR Condition
              |
              CondTerm
              ;

CondTerm ::= CondFact AND CondTerm
             |
             CondFact
             ;

CondFact ::= Expr Relop CondFact
             |
             Expr
             ;

Expr ::= (ExprTerm) Term
         |
         (ExprMinusTerm) MINUS Term
         |
         (ExprAddopTerm) Expr Addop Term
         |
         Designator MapDesignator
         ;

MapDesignator ::= MAP Designator
                  ;

Term ::= (TermFactor) Factor
         |
         (TermTermMulopFactor) Term Mulop Factor
         ;

Factor ::= (FactorDesignator) Designator
           |
           (FactorFuncCall)Designator DesignatorFuncCall
           |
           (FactorConstDeclListValue) ConstDeclListValue
           |
           (FactorCreateArray) NEW Type LBRACKET Expr RBRACKET
           |
           NEW Type DesignatorFuncCall
           |
           (FactorExpr) LPAREN Expr RPAREN
           ;

DesignatorFuncCall ::= LPAREN RPAREN
                   |
                   LPAREN ActPars RPAREN
                   ;

Label ::= IDENT ;

Assignop ::= EQ ;

Relop ::= EQEQ | NOTEQ | GR | GREQ | LE | LEQ ;

Addop ::= PLUS | MINUS ;

Mulop ::= MUL | DIV | MOD ;

Setop ::= UNION ;
