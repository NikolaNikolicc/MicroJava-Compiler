package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, UNION, DO, WHILE, MAP, INTERFACE, PLUS, MINUS, MUL, DIV, MOD, EQEQ, NOTEQ, GR, GREQ, LE, LEQ, AND, OR, EQ, INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, MAIN ;
terminal Integer NUMBER, BOOL ;
terminal String IDENT ;
terminal Character CHAR ;

nonterminal MethodSignatureEndFormPars MethodSignatureEndFormPars;
nonterminal MethodSignatureStartFormPars MethodSignatureStartFormPars;
nonterminal ConstDeclAssign ConstDeclAssign;
nonterminal Setop Setop;
nonterminal Mulop Mulop;
nonterminal Addop Addop;
nonterminal Relop Relop;
nonterminal Assignop Assignop;
nonterminal Label Label;
nonterminal ProgramDeclList ProgramDeclList;
nonterminal ProgramDeclElem ProgramDeclElem;
nonterminal ConstDecl ConstDecl;
nonterminal ConstDeclList ConstDeclList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclFinal VarDeclFinal;
nonterminal VarDeclOptionalList VarDeclOptionalList;
nonterminal ClassDecl ClassDecl;
nonterminal VarDeclListOptional VarDeclListOptional;
nonterminal MethodSignature MethodSignature;
nonterminal TypeChoice TypeChoice;
nonterminal FormParsOptional FormParsOptional;
nonterminal FormPars FormPars;
nonterminal MethodDecl MethodDecl;
nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal MathodDecl MathodDecl;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActPars ActPars;
nonterminal DesignatorFuncCall DesignatorFuncCall;
nonterminal DesignatorStatementUnary DesignatorStatementUnary;
nonterminal StackInitialize StackInitialize;
nonterminal MapDesignator MapDesignator;
nonterminal ClassDeclName ClassDeclName;
nonterminal ClassMethodDeclListStart ClassMethodDeclListStart;
nonterminal Program Program;
nonterminal InterfaceDeclOptionList InterfaceDeclOptionList;
nonterminal InterfaceDecl InterfaceDecl;
nonterminal VarDeclProgram VarDeclProgram;
nonterminal VarDeclErrorComma VarDeclErrorComma;
nonterminal VarDeclErrorSemi VarDeclErrorSemi;
nonterminal DesignatorAssign DesignatorAssign;
nonterminal VarDeclClass VarDeclClass;
nonterminal ClassDeclErrorLBrace ClassDeclErrorLBrace;
nonterminal DesignatorAssignWhile DesignatorAssignWhile;
nonterminal DesignatorStatementWhile DesignatorStatementWhile;
nonterminal DoStatement DoStatement ;
nonterminal ExtendsClass ExtendsClass;
nonterminal CopyParentMethods CopyParentMethods;
nonterminal CloseMethodScope CloseMethodScope;
nonterminal InterfaceDeclName InterfaceDeclName;
nonterminal Else Else;
nonterminal WhileStatement WhileStatement;
nonterminal HandleWhileCondition HandleWhileCondition;
nonterminal GoToStart GoToStart;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr, CondFact, CondTerm, Condition, StatementCondition, Type;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ConstDeclListValue, Designator, DesignatorArrayName, DesignatorClassMore, DesignatorClassArrayName, DesignatorClassName, DesignatorClassElem;

nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodName;

precedence left ELSE;

Program ::= (Program)  PROG ProgName:P1 ProgramDeclList:P2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(P1, P2, M3); RESULT.setLine(P1left); :} ;

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

ProgramDeclList ::= ProgramDeclList:P1 ProgramDeclElem:P2 {: RESULT=new ProgramDeclListDerived1(P1, P2); RESULT.setLine(P1left); :}
                    | {: RESULT=new ProgramDeclListDerived2(); :}
                    /* epsilon */
                    ;

ProgramDeclElem ::= ConstDecl:C1 {: RESULT=new ProgramDeclElemDerived1(C1); RESULT.setLine(C1left); :}
                    |
                    VarDeclProgram:V1 {: RESULT=new ProgramDeclElemDerived2(V1); RESULT.setLine(V1left); :}
                    |
                    ClassDecl:C1 {: RESULT=new ProgramDeclElemDerived3(C1); RESULT.setLine(C1left); :}
                    |
                    InterfaceDecl:I1 {: RESULT=new ProgramDeclElemDerived4(I1); RESULT.setLine(I1left); :}
                    ;

VarDeclProgram ::= VarDeclErrorSemi:V1 {: RESULT=new VarDeclProgramDerived1(V1); RESULT.setLine(V1left); :}
                   |
                   VarDeclErrorComma:V1 VarDeclFinal:V2 VarDeclOptionalList:V3 SEMI {: RESULT=new VarDeclProgramDerived2(V1, V2, V3); RESULT.setLine(V1left); :}
                   |
                   VarDecl:V1 {: RESULT=new VarDeclProgramDerived3(V1); RESULT.setLine(V1left); :}
                   ;

VarDeclErrorComma ::= error COMMA:l
                      {: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null); :} {: RESULT=new VarDeclErrorCommaDerived1(); :}
                      ;

VarDeclErrorSemi ::= error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new VarDeclErrorSemiDerived1(); :}
                     ;

ConstDecl ::= CONST Type:T1 ConstDeclList:C2 SEMI {: RESULT=new ConstDeclDerived1(T1, C2); RESULT.setLine(T1left); :} ;

ConstDeclListValue ::= (NumConst)NUMBER:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
                       |
                       (CharConst)CHAR:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
                       |
                       (BoolConst)BOOL:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :}
                       ;

ConstDeclList ::= ConstDeclList:C1 COMMA ConstDeclAssign:C2 {: RESULT=new ConstDeclListDerived1(C1, C2); RESULT.setLine(C1left); :}
                          |
                          ConstDeclAssign:C1 {: RESULT=new ConstDeclListDerived2(C1); RESULT.setLine(C1left); :}
                          ;

ConstDeclAssign ::= (ConstDeclAssign)IDENT:I1 EQ ConstDeclListValue:C2 {: RESULT=new ConstDeclAssign(I1, C2); RESULT.setLine(I1left); :} ;

VarDecl ::= Type:T1 VarDeclFinal:V2 VarDeclOptionalList:V3 SEMI {: RESULT=new VarDeclDerived1(T1, V2, V3); RESULT.setLine(T1left); :}
            ;

VarDeclFinal ::= (VarDeclFinalArray)IDENT:I1 LBRACKET RBRACKET {: RESULT=new VarDeclFinalArray(I1); RESULT.setLine(I1left); :}
                 |
                 (VarDeclFinalVar)IDENT:I1 {: RESULT=new VarDeclFinalVar(I1); RESULT.setLine(I1left); :}
                 ;

VarDeclOptionalList ::= VarDeclOptionalList:V1 COMMA VarDeclFinal:V2 {: RESULT=new VarDeclOptionalListDerived1(V1, V2); RESULT.setLine(V1left); :}
                        | {: RESULT=new VarDeclOptionalListDerived2(); :}
                        /* epsilon */
                        ;

InterfaceDecl ::= (InterfaceDecl) INTERFACE InterfaceDeclName:I1 LBRACE InterfaceDeclOptionList:I2 RBRACE {: RESULT=new InterfaceDecl(I1, I2); RESULT.setLine(I1left); :}
                  ;

InterfaceDeclName ::= (InterfaceDeclName) IDENT:I1 {: RESULT=new InterfaceDeclName(I1); RESULT.setLine(I1left); :} ;

InterfaceDeclOptionList ::= InterfaceDeclOptionList:I1 MethodDecl:M2 {: RESULT=new InterfaceDeclOptionListDerived1(I1, M2); RESULT.setLine(I1left); :}
                            |
                            InterfaceDeclOptionList:I1 MethodSignature:M2 CloseMethodScope:C3 SEMI {: RESULT=new InterfaceDeclOptionListDerived2(I1, M2, C3); RESULT.setLine(I1left); :}
                            | {: RESULT=new InterfaceDeclOptionListDerived3(); :}
                            /* epsilon */
                            ;

CloseMethodScope ::= (CloseMethodScope) {: RESULT=new CloseMethodScope(); :} /* epsilon */ ;

ClassDecl ::= (ClassNoExtend) CLASS ClassDeclName:C1 LBRACE VarDeclListOptional:V2 RBRACE {: RESULT=new ClassNoExtend(C1, V2); RESULT.setLine(C1left); :}
              |
              (ClassYesExtend) CLASS ClassDeclName:C1 ExtendsClass:E2 LBRACE VarDeclListOptional:V3 RBRACE CopyParentMethods:C4 {: RESULT=new ClassYesExtend(C1, E2, V3, C4); RESULT.setLine(C1left); :}
              |
              CLASS ClassDeclName:C1 EXTENDS ClassDeclErrorLBrace:C2 VarDeclListOptional:V3 RBRACE {: RESULT=new ClassDeclDerived1(C1, C2, V3); RESULT.setLine(C1left); :} /* error */
              |
              (ClassNoExtendYesMethods) CLASS ClassDeclName:C1 LBRACE VarDeclListOptional:V2 LBRACE ClassMethodDeclListStart:C3 MethodDeclList:M4 RBRACE RBRACE {: RESULT=new ClassNoExtendYesMethods(C1, V2, C3, M4); RESULT.setLine(C1left); :}
              |
              (ClassYesExtendYesMethods) CLASS ClassDeclName:C1 ExtendsClass:E2 LBRACE VarDeclListOptional:V3 CopyParentMethods:C4 LBRACE ClassMethodDeclListStart:C5 MethodDeclList:M6 RBRACE RBRACE {: RESULT=new ClassYesExtendYesMethods(C1, E2, V3, C4, C5, M6); RESULT.setLine(C1left); :}
              |
              CLASS ClassDeclName:C1 EXTENDS ClassDeclErrorLBrace:C2 VarDeclListOptional:V3 LBRACE ClassMethodDeclListStart:C4 MethodDeclList:M5 RBRACE RBRACE {: RESULT=new ClassDeclDerived2(C1, C2, V3, C4, M5); RESULT.setLine(C1left); :} /* error */
              |
              CLASS ClassDeclName:C1 LBRACE VarDeclListOptional:V2 ClassDeclErrorLBrace:C3 ClassMethodDeclListStart:C4 MethodDeclList:M5 RBRACE RBRACE {: RESULT=new ClassDeclDerived3(C1, V2, C3, C4, M5); RESULT.setLine(C1left); :} /* error */
              |
              CLASS ClassDeclName:C1 ExtendsClass:E2 LBRACE VarDeclListOptional:V3 ClassDeclErrorLBrace:C4 CopyParentMethods:C5 ClassMethodDeclListStart:C6 MethodDeclList:M7 RBRACE RBRACE {: RESULT=new ClassDeclDerived4(C1, E2, V3, C4, C5, C6, M7); RESULT.setLine(C1left); :} /* error */
              |
              CLASS ClassDeclName:C1 EXTENDS ClassDeclErrorLBrace:C2 VarDeclListOptional:V3 ClassDeclErrorLBrace:C4 ClassMethodDeclListStart:C5 MethodDeclList:M6 RBRACE RBRACE {: RESULT=new ClassDeclDerived5(C1, C2, V3, C4, C5, M6); RESULT.setLine(C1left); :} /* error */
              ;

CopyParentMethods ::= (CopyParentMethods) {: RESULT=new CopyParentMethods(); :} /* epsilon */ ;

ExtendsClass ::= (ExtendsClass) EXTENDS Type:T1 {: RESULT=new ExtendsClass(T1); RESULT.setLine(T1left); :} ;

ClassMethodDeclListStart ::= (ClassMethodDeclListStart) {: RESULT=new ClassMethodDeclListStart(); :} /* epsilon */ ;

ClassDeclName ::= (ClassDeclName) IDENT:I1 {: RESULT=new ClassDeclName(I1); RESULT.setLine(I1left); :};

VarDeclListOptional ::= VarDeclListOptional:V1 VarDeclClass:V2 {: RESULT=new VarDeclListOptionalDerived1(V1, V2); RESULT.setLine(V1left); :}
                        | {: RESULT=new VarDeclListOptionalDerived2(); :}
                        /* epsilon */
                        ;

ClassDeclErrorLBrace ::= error LBRACE:l
                         {: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null); :} {: RESULT=new ClassDeclErrorLBraceDerived1(); :}
                         ;

VarDeclClass ::= VarDecl:V1 {: RESULT=new VarDeclClassDerived1(V1); RESULT.setLine(V1left); :}
                 |
                 error SEMI:l
                 {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new VarDeclClassDerived2(); :}
                 ;

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}
                   | {: RESULT=new MethodDeclListDerived2(); :}
                   /* epsilon */
                   ;

MethodSignature ::= TypeChoice:T1 MethodName:M2 MethodSignatureStartFormPars:M3 FormParsOptional:F4 {: RESULT=new MethodSignatureDerived1(T1, M2, M3, F4); RESULT.setLine(T1left); :}
                    ;

MethodSignatureStartFormPars ::= (MethodSignatureStartFormPars)LPAREN {: RESULT=new MethodSignatureStartFormPars(); :} ;

MethodSignatureEndFormPars ::= (MethodSignatureEndFormPars)RPAREN {: RESULT=new MethodSignatureEndFormPars(); :} ;

MethodName ::= (RegularMethod)IDENT:I1 {: RESULT=new RegularMethod(I1); RESULT.setLine(I1left); :}
               |
               (MainMethod)MAIN {: RESULT=new MainMethod(); :}
               ;

TypeChoice ::= (NoVoidMethod)IDENT:I1 {: RESULT=new NoVoidMethod(I1); RESULT.setLine(I1left); :}
               |
               (VoidMethod)VOID {: RESULT=new VoidMethod(); :}
               ;

FormParsOptional ::=  FormPars:F1 {: RESULT=new FormParsOptionalDerived1(F1); RESULT.setLine(F1left); :}
                      |
                      MethodSignatureEndFormPars:M1 {: RESULT=new FormParsOptionalDerived2(M1); RESULT.setLine(M1left); :} /* epsilon */
                      ;

MethodDecl ::= (MethodDecl)MethodSignature:M1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDecl(M1, V2, S3); RESULT.setLine(M1left); :}
               ;

VarDeclList ::= VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
                | {: RESULT=new VarDeclListDerived2(); :}
                /* epsilon */
                ;

FormPars ::= Type:T1 VarDeclFinal:V2 MethodSignatureEndFormPars:M3 {: RESULT=new FormParsDerived1(T1, V2, M3); RESULT.setLine(T1left); :}
             |
             error MethodSignatureEndFormPars:l
             {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :} {: RESULT=new FormParsDerived2(l); RESULT.setLine(lleft); :}
             |
             Type:T1 VarDeclFinal:V2 COMMA FormPars:F3 {: RESULT=new FormParsDerived3(T1, V2, F3); RESULT.setLine(T1left); :}
             |
             VarDeclErrorComma:V1 FormPars:F2 {: RESULT=new FormParsDerived4(V1, F2); RESULT.setLine(V1left); :}
             ;

Type ::= (TypeIdent) IDENT:I1 {: RESULT=new TypeIdent(I1); RESULT.setLine(I1left); :}
         ;

StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
                  | {: RESULT=new StatementListDerived2(); :}
                  /* epsilon */
                  ;

Statement ::=   DesignatorStatement:D1 {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
              |
              (StatementElse) IF LPAREN StatementCondition:S1 Statement:S2 Else:E3 Statement:S4 {: RESULT=new StatementElse(S1, S2, E3, S4); RESULT.setLine(S1left); :}
              |
              (StatementNoElse) IF LPAREN StatementCondition:S1 Statement:S2 {: RESULT=new StatementNoElse(S1, S2); RESULT.setLine(S1left); :}
              |
              (StatementBreak) BREAK SEMI {: RESULT=new StatementBreak(); :}
              |
              (StatementContinue) CONTINUE SEMI {: RESULT=new StatementContinue(); :}
              |
              (StatementReturn) RETURN SEMI {: RESULT=new StatementReturn(); :}
              |
              (StatementReturnExpr) RETURN Expr:E1 SEMI {: RESULT=new StatementReturnExpr(E1); RESULT.setLine(E1left); :}
              |
              (StatementRead) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementRead(D1); RESULT.setLine(D1left); :}
              |
              (StatementPrint) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StatementPrint(E1); RESULT.setLine(E1left); :}
              |
              (StatementPrintNumber) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new StatementPrintNumber(E1, N2); RESULT.setLine(E1left); :}
              |
              (StatementLoopSimple) DoStatement:D1 Statement:S2 WhileStatement:W3 LPAREN RPAREN GoToStart:G4 SEMI {: RESULT=new StatementLoopSimple(D1, S2, W3, G4); RESULT.setLine(D1left); :}
              |
              (StatementLoopCondition) DoStatement:D1 Statement:S2 WhileStatement:W3 LPAREN Condition:C4 HandleWhileCondition:H5 RPAREN GoToStart:G6 SEMI {: RESULT=new StatementLoopCondition(D1, S2, W3, C4, H5, G6); RESULT.setLine(D1left); :}
              |
              (StatementLoopComplex) DoStatement:D1 Statement:S2 WhileStatement:W3 LPAREN Condition:C4 COMMA HandleWhileCondition:H5 DesignatorStatementWhile:D6 RPAREN GoToStart:G7 SEMI {: RESULT=new StatementLoopComplex(D1, S2, W3, C4, H5, D6, G7); RESULT.setLine(D1left); :}
              |
              LBRACE StatementList:S1 RBRACE {: RESULT=new StatementDerived2(S1); RESULT.setLine(S1left); :}
              ;

Else ::= (Else) ELSE {: RESULT=new Else(); :} ;

DoStatement ::= (DoStatement) DO {: RESULT=new DoStatement(); :};

WhileStatement ::= (WhileStatement) WHILE {: RESULT=new WhileStatement(); :};

HandleWhileCondition ::= (HandleWhileCondition) {: RESULT=new HandleWhileCondition(); :} /* epsilon */ ;

GoToStart ::= (GoToStart) {: RESULT=new GoToStart(); :} /* epsilon */ ;


DesignatorStatementWhile ::= (DesignatorStatementFuncCallWhile)Designator:D1 DesignatorFuncCall:D2 {: RESULT=new DesignatorStatementFuncCallWhile(D1, D2); RESULT.setLine(D1left); :}
                             |
                             (DesignatorStatementUnarySemiWhile) Designator:D1 DesignatorStatementUnary:D2 {: RESULT=new DesignatorStatementUnarySemiWhile(D1, D2); RESULT.setLine(D1left); :}
                             |
                             DesignatorAssignWhile:D1 {: RESULT=new DesignatorStatementWhileDerived1(D1); RESULT.setLine(D1left); :}
                             ;

DesignatorAssignWhile ::= (DesignatorAssignExprWhile) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorAssignExprWhile(D1, A2, E3); RESULT.setLine(D1left); :}
                          |
                          (DesignatorAssignSetopWhile) Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 {: RESULT=new DesignatorAssignSetopWhile(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
                          ;

StatementCondition ::= (StatementConditionCondition) Condition:C1 RPAREN {: RESULT=new StatementConditionCondition(C1); RESULT.setLine(C1left); :}
                       |
                       error RPAREN:l
                       {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :} {: RESULT=new StatementConditionDerived1(); :}
                       ;


DesignatorStatement ::= (DesignatorStatementUnarySemi) Designator:D1 DesignatorStatementUnary:D2 SEMI {: RESULT=new DesignatorStatementUnarySemi(D1, D2); RESULT.setLine(D1left); :}
                        |
                        (DesignatorStatementFuncCall) Designator:D1 DesignatorFuncCall:D2 SEMI {: RESULT=new DesignatorStatementFuncCall(D1, D2); RESULT.setLine(D1left); :}
                        |
                        DesignatorAssign:D1 {: RESULT=new DesignatorStatementDerived1(D1); RESULT.setLine(D1left); :}
                        ;

DesignatorAssign ::= (DesignatorAssignExpr) Designator:D1 Assignop:A2 Expr:E3 SEMI {: RESULT=new DesignatorAssignExpr(D1, A2, E3); RESULT.setLine(D1left); :}
                     |
                     (DesignatorAssignSetop) Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 SEMI {: RESULT=new DesignatorAssignSetop(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
                     |
                     error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new DesignatorAssignDerived1(); :}
                     ;

DesignatorStatementUnary ::= (UnaryInc) INC {: RESULT=new UnaryInc(); :}
                             |
                             (UnaryDec) DEC {: RESULT=new UnaryDec(); :}
                             ;

Designator ::= (DesignatorVar) IDENT:I1 {: RESULT=new DesignatorVar(I1); RESULT.setLine(I1left); :}
               |
               (DesignatorPropertyAccess) DesignatorClassName:D1 DesignatorClassMore:D2 {: RESULT=new DesignatorPropertyAccess(D1, D2); RESULT.setLine(D1left); :}
               |
               (DesignatorElem) DesignatorArrayName:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorElem(D1, E2); RESULT.setLine(D1left); :}
               |
               (DesignatorElemPropertyAccess) DesignatorClassElem:D1 DesignatorClassMore:D2 {: RESULT=new DesignatorElemPropertyAccess(D1, D2); RESULT.setLine(D1left); :}
               ;

DesignatorClassMore ::= (DesignatorClassMoreFinal) DOT IDENT:I1 {: RESULT=new DesignatorClassMoreFinal(I1); RESULT.setLine(I1left); :}
                        |
                        (DesignatorClassMoreFinalElem) DOT DesignatorClassArrayName:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorClassMoreFinalElem(D1, E2); RESULT.setLine(D1left); :}
                        |
                        (DesignatorClassMoreNotFinal) DesignatorClassMore:D1 DOT IDENT:I2 {: RESULT=new DesignatorClassMoreNotFinal(D1, I2); RESULT.setLine(D1left); :}
                        |
                        (DesignatorClassMoreNotFinalElem) DesignatorClassMore:D1 DOT DesignatorClassArrayName:D2 LBRACKET Expr:E3 RBRACKET {: RESULT=new DesignatorClassMoreNotFinalElem(D1, D2, E3); RESULT.setLine(D1left); :}
                        ;

DesignatorClassElem ::= (DesignatorClassElem) DesignatorArrayName:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorClassElem(D1, E2); RESULT.setLine(D1left); :} ;
DesignatorClassName ::= (DesignatorClassName) IDENT:I1 {: RESULT=new DesignatorClassName(I1); RESULT.setLine(I1left); :};
DesignatorClassArrayName ::= (DesignatorClassArrayName) IDENT:I1 {: RESULT=new DesignatorClassArrayName(I1); RESULT.setLine(I1left); :};
DesignatorArrayName ::= (DesignatorArrayName) IDENT:I1 {: RESULT=new DesignatorArrayName(I1); RESULT.setLine(I1left); :};

ActPars ::= (ActParsMultipleItems) Expr:E1 COMMA ActPars:A2 {: RESULT=new ActParsMultipleItems(E1, A2); RESULT.setLine(E1left); :}
            |
            (ActParsSigleItem) Expr:E1 {: RESULT=new ActParsSigleItem(E1); RESULT.setLine(E1left); :}
            ;

Condition ::= (ConditionOr) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionOr(C1, C2); RESULT.setLine(C1left); :}
              |
              (ConditionCondTerm) CondTerm:C1 {: RESULT=new ConditionCondTerm(C1); RESULT.setLine(C1left); :}
              ;

CondTerm ::= (CondTermAnd) CondFact:C1 AND CondTerm:C2 {: RESULT=new CondTermAnd(C1, C2); RESULT.setLine(C1left); :}
             |
             (CondTermCondFact) CondFact:C1 {: RESULT=new CondTermCondFact(C1); RESULT.setLine(C1left); :}
             ;

CondFact ::= (CondFactRelop) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFactRelop(E1, R2, E3); RESULT.setLine(E1left); :}
             |
             (CondFactExpr) Expr:E1 {: RESULT=new CondFactExpr(E1); RESULT.setLine(E1left); :}
             ;

Expr ::= (ExprTerm) Term:T1 {: RESULT=new ExprTerm(T1); RESULT.setLine(T1left); :}
         |
         (ExprMinusTerm) MINUS Term:T1 {: RESULT=new ExprMinusTerm(T1); RESULT.setLine(T1left); :}
         |
         (ExprAddopTerm) Expr:E1 Addop:A2 Term:T3 {: RESULT=new ExprAddopTerm(E1, A2, T3); RESULT.setLine(E1left); :}
         |
         (ExprDesignatorMap) Designator:D1 MapDesignator:M2 {: RESULT=new ExprDesignatorMap(D1, M2); RESULT.setLine(D1left); :}
         ;

MapDesignator ::= (MapDesignator) MAP Designator:D1 {: RESULT=new MapDesignator(D1); RESULT.setLine(D1left); :}
                  ;

Term ::= (TermFactor) Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :}
         |
         (TermTermMulopFactor) Term:T1 Mulop:M2 Factor:F3 {: RESULT=new TermTermMulopFactor(T1, M2, F3); RESULT.setLine(T1left); :}
         ;

Factor ::= (FactorDesignator) Designator:D1 {: RESULT=new FactorDesignator(D1); RESULT.setLine(D1left); :}
           |
           (FactorFuncCall)Designator:D1 DesignatorFuncCall:D2 {: RESULT=new FactorFuncCall(D1, D2); RESULT.setLine(D1left); :}
           |
           (FactorConstDeclListValue) ConstDeclListValue:C1 {: RESULT=new FactorConstDeclListValue(C1); RESULT.setLine(C1left); :}
           |
           (FactorCreateArray) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new FactorCreateArray(T1, E2); RESULT.setLine(T1left); :}
           |
           (FactorCreateObject) NEW Type:T1 DesignatorFuncCall:D2 {: RESULT=new FactorCreateObject(T1, D2); RESULT.setLine(T1left); :}
           |
           (FactorExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorExpr(E1); RESULT.setLine(E1left); :}
           ;

DesignatorFuncCall ::= LPAREN StackInitialize:S1 RPAREN {: RESULT=new DesignatorFuncCallDerived1(S1); RESULT.setLine(S1left); :}
                   |
                   LPAREN StackInitialize:S1 ActPars:A2 RPAREN {: RESULT=new DesignatorFuncCallDerived2(S1, A2); RESULT.setLine(S1left); :}
                   ;

StackInitialize ::= (StackInitialize) {: RESULT=new StackInitialize(); :} /* epsilon */;

Label ::= IDENT:I1 {: RESULT=new LabelDerived1(I1); RESULT.setLine(I1left); :} ;

Assignop ::= EQ {: RESULT=new AssignopDerived1(); :} ;

Relop ::= (RelopEqual) EQEQ {: RESULT=new RelopEqual(); :} | (RelopNotEqual) NOTEQ {: RESULT=new RelopNotEqual(); :} | (RelopGreaterThan) GR {: RESULT=new RelopGreaterThan(); :} | (RelopGreaterThanOrEqual) GREQ {: RESULT=new RelopGreaterThanOrEqual(); :} | (RelopLessThan) LE {: RESULT=new RelopLessThan(); :} | (RelopLessThanOrEqual) LEQ {: RESULT=new RelopLessThanOrEqual(); :} ;

Addop ::= (AddopPlus)PLUS {: RESULT=new AddopPlus(); :} | (AddopMinus)MINUS {: RESULT=new AddopMinus(); :} ;

Mulop ::= (MulopMul)MUL {: RESULT=new MulopMul(); :} | (MulopDiv)DIV {: RESULT=new MulopDiv(); :} | (MulopMod)MOD {: RESULT=new MulopMod(); :} ;

Setop ::= UNION {: RESULT=new SetopDerived1(); :} ;