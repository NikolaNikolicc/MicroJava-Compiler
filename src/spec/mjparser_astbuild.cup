package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, SET, UNION, DO, WHILE, MAP, INTERFACE, PLUS, MINUS, MUL, DIV, MOD, EQEQ, NOTEQ, GR, GREQ, LE, LEQ, AND, OR, EQ, INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, MAIN ;
terminal Integer NUMBER, BOOL ;
terminal String IDENT ;
terminal Character CHAR ;

nonterminal Type Type;
nonterminal MethodSignatureEndFormPars MethodSignatureEndFormPars;
nonterminal MethodSignatureStartFormPars MethodSignatureStartFormPars;
nonterminal MethodName MethodName;
nonterminal ConstDeclAssign ConstDeclAssign;
nonterminal Setop Setop;
nonterminal Mulop Mulop;
nonterminal Addop Addop;
nonterminal Relop Relop;
nonterminal Assignop Assignop;
nonterminal Label Label;
nonterminal ProgramDeclList ProgramDeclList;
nonterminal ProgramDeclElem ProgramDeclElem;
nonterminal ConstDecl ConstDecl;
nonterminal ConstDeclList ConstDeclList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclFinal VarDeclFinal;
nonterminal VarDeclOptionalList VarDeclOptionalList;
nonterminal ClassDecl ClassDecl;
nonterminal VarDeclListOptional VarDeclListOptional;
nonterminal MethodSignature MethodSignature;
nonterminal TypeChoice TypeChoice;
nonterminal FormParsOptional FormParsOptional;
nonterminal FormPars FormPars;
nonterminal MethodDecl MethodDecl;
nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal MathodDecl MathodDecl;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Designator Designator;
nonterminal DesignatorListElem DesignatorListElem;
nonterminal DesignatorList DesignatorList;
nonterminal ActPars ActPars;
nonterminal FactorOptional FactorOptional;
nonterminal FactorChoice FactorChoice;
nonterminal MapDesignator MapDesignator;
nonterminal DesignatorStatementChoice DesignatorStatementChoice;
nonterminal CondFact CondFact;
nonterminal CondTerm CondTerm;
nonterminal CondFactList CondFactList;
nonterminal Condition Condition;
nonterminal ConditionList ConditionList ;
nonterminal Program Program;
nonterminal InterfaceDeclOptionList InterfaceDeclOptionList;
nonterminal InterfaceDecl InterfaceDecl;
nonterminal VarDeclProgram VarDeclProgram;
nonterminal VarDeclErrorComma VarDeclErrorComma;
nonterminal VarDeclErrorSemi VarDeclErrorSemi;
nonterminal DesignatorAssign DesignatorAssign;
nonterminal StatementCondition StatementCondition;
nonterminal VarDeclClass VarDeclClass;
nonterminal ClassDeclErrorLBrace ClassDeclErrorLBrace;
nonterminal DesignatorAssignWhile DesignatorAssignWhile;
nonterminal DesignatorStatementWhile DesignatorStatementWhile ;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Term, Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ConstDeclListValue;

precedence left ELSE;

Program ::= (Program)  PROG ProgName:P1 ProgramDeclList:P2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(P1, P2, M3); RESULT.setLine(P1left); :} ;

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

ProgramDeclList ::= ProgramDeclList:P1 ProgramDeclElem:P2 {: RESULT=new ProgramDeclListDerived1(P1, P2); RESULT.setLine(P1left); :}
                    | {: RESULT=new ProgramDeclListDerived2(); :}
                    /* epsilon */
                    ;

ProgramDeclElem ::= ConstDecl:C1 {: RESULT=new ProgramDeclElemDerived1(C1); RESULT.setLine(C1left); :}
                    |
                    VarDeclProgram:V1 {: RESULT=new ProgramDeclElemDerived2(V1); RESULT.setLine(V1left); :}
                    |
                    ClassDecl:C1 {: RESULT=new ProgramDeclElemDerived3(C1); RESULT.setLine(C1left); :}
                    |
                    InterfaceDecl:I1 {: RESULT=new ProgramDeclElemDerived4(I1); RESULT.setLine(I1left); :}
                    ;

VarDeclProgram ::= VarDeclErrorSemi:V1 {: RESULT=new VarDeclProgramDerived1(V1); RESULT.setLine(V1left); :}
                   |
                   VarDeclErrorComma:V1 VarDeclFinal:V2 VarDeclOptionalList:V3 SEMI {: RESULT=new VarDeclProgramDerived2(V1, V2, V3); RESULT.setLine(V1left); :}
                   |
                   VarDecl:V1 {: RESULT=new VarDeclProgramDerived3(V1); RESULT.setLine(V1left); :}
                   ;

VarDeclErrorComma ::= error COMMA:l
                      {: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null); :} {: RESULT=new VarDeclErrorCommaDerived1(); :}
                      ;

VarDeclErrorSemi ::= error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new VarDeclErrorSemiDerived1(); :}
                     ;

ConstDecl ::= CONST Type:T1 ConstDeclList:C2 SEMI {: RESULT=new ConstDeclDerived1(T1, C2); RESULT.setLine(T1left); :} ;

ConstDeclListValue ::= (NumConst)NUMBER:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
                       |
                       (CharConst)CHAR:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
                       |
                       (BoolConst)BOOL:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :}
                       ;

ConstDeclList ::= ConstDeclList:C1 COMMA ConstDeclAssign:C2 {: RESULT=new ConstDeclListDerived1(C1, C2); RESULT.setLine(C1left); :}
                          |
                          ConstDeclAssign:C1 {: RESULT=new ConstDeclListDerived2(C1); RESULT.setLine(C1left); :}
                          ;

ConstDeclAssign ::= (ConstDeclAssign)IDENT:I1 EQ ConstDeclListValue:C2 {: RESULT=new ConstDeclAssign(I1, C2); RESULT.setLine(I1left); :} ;

VarDecl ::= Type:T1 VarDeclFinal:V2 VarDeclOptionalList:V3 SEMI {: RESULT=new VarDeclDerived1(T1, V2, V3); RESULT.setLine(T1left); :}
            ;

VarDeclFinal ::= (VarDeclFinalArray)IDENT:I1 LBRACKET RBRACKET {: RESULT=new VarDeclFinalArray(I1); RESULT.setLine(I1left); :}
                 |
                 (VarDeclFinalVar)IDENT:I1 {: RESULT=new VarDeclFinalVar(I1); RESULT.setLine(I1left); :}
                 ;

VarDeclOptionalList ::= VarDeclOptionalList:V1 COMMA VarDeclFinal:V2 {: RESULT=new VarDeclOptionalListDerived1(V1, V2); RESULT.setLine(V1left); :}
                        | {: RESULT=new VarDeclOptionalListDerived2(); :}
                        /* epsilon */
                        ;

InterfaceDecl ::= INTERFACE IDENT:I1 LBRACE InterfaceDeclOptionList:I2 RBRACE {: RESULT=new InterfaceDeclDerived1(I1, I2); RESULT.setLine(I1left); :}
                  ;

InterfaceDeclOptionList ::= InterfaceDeclOptionList:I1 MethodDecl:M2 {: RESULT=new InterfaceDeclOptionListDerived1(I1, M2); RESULT.setLine(I1left); :}
                            |
                            InterfaceDeclOptionList:I1 MethodSignature:M2 SEMI {: RESULT=new InterfaceDeclOptionListDerived2(I1, M2); RESULT.setLine(I1left); :}
                            | {: RESULT=new InterfaceDeclOptionListDerived3(); :}
                            /* epsilon */
                            ;

ClassDecl ::= CLASS IDENT:I1 LBRACE VarDeclListOptional:V2 RBRACE {: RESULT=new ClassDeclDerived1(I1, V2); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 EXTENDS Type:T2 LBRACE VarDeclListOptional:V3 RBRACE {: RESULT=new ClassDeclDerived2(I1, T2, V3); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 EXTENDS ClassDeclErrorLBrace:C2 VarDeclListOptional:V3 RBRACE {: RESULT=new ClassDeclDerived3(I1, C2, V3); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 LBRACE VarDeclListOptional:V2 LBRACE MethodDeclList:M3 RBRACE RBRACE {: RESULT=new ClassDeclDerived4(I1, V2, M3); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 EXTENDS Type:T2 LBRACE VarDeclListOptional:V3 LBRACE MethodDeclList:M4 RBRACE RBRACE {: RESULT=new ClassDeclDerived5(I1, T2, V3, M4); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 EXTENDS ClassDeclErrorLBrace:C2 VarDeclListOptional:V3 LBRACE MethodDeclList:M4 RBRACE RBRACE {: RESULT=new ClassDeclDerived6(I1, C2, V3, M4); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 LBRACE VarDeclListOptional:V2 ClassDeclErrorLBrace:C3 MethodDeclList:M4 RBRACE RBRACE {: RESULT=new ClassDeclDerived7(I1, V2, C3, M4); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 EXTENDS Type:T2 LBRACE VarDeclListOptional:V3 ClassDeclErrorLBrace:C4 MethodDeclList:M5 RBRACE RBRACE {: RESULT=new ClassDeclDerived8(I1, T2, V3, C4, M5); RESULT.setLine(I1left); :}
              |
              CLASS IDENT:I1 EXTENDS ClassDeclErrorLBrace:C2 VarDeclListOptional:V3 ClassDeclErrorLBrace:C4 MethodDeclList:M5 RBRACE RBRACE {: RESULT=new ClassDeclDerived9(I1, C2, V3, C4, M5); RESULT.setLine(I1left); :}
              ;

VarDeclListOptional ::= VarDeclListOptional:V1 VarDeclClass:V2 {: RESULT=new VarDeclListOptionalDerived1(V1, V2); RESULT.setLine(V1left); :}
                        | {: RESULT=new VarDeclListOptionalDerived2(); :}
                        /* epsilon */
                        ;

ClassDeclErrorLBrace ::= error LBRACE:l
                         {: parser.report_error("Izvrsen oporavak do { u liniji " + lleft, null); :} {: RESULT=new ClassDeclErrorLBraceDerived1(); :}
                         ;

VarDeclClass ::= Type:T1 IDENT:I2 VarDeclFinal:V3 VarDeclOptionalList:V4 SEMI {: RESULT=new VarDeclClassDerived1(T1, I2, V3, V4); RESULT.setLine(T1left); :}
                 |
                 error SEMI:l
                 {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new VarDeclClassDerived2(); :}
                 ;

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}
                   | {: RESULT=new MethodDeclListDerived2(); :}
                   /* epsilon */
                   ;

MethodSignature ::= TypeChoice:T1 MethodName:M2 MethodSignatureStartFormPars:M3 FormParsOptional:F4 {: RESULT=new MethodSignatureDerived1(T1, M2, M3, F4); RESULT.setLine(T1left); :}
                    ;

MethodSignatureStartFormPars ::= (MethodSignatureStartFormPars)LPAREN {: RESULT=new MethodSignatureStartFormPars(); :} ;

MethodSignatureEndFormPars ::= (MethodSignatureEndFormPars)RPAREN {: RESULT=new MethodSignatureEndFormPars(); :} ;

MethodName ::= (RegularMethod)IDENT:I1 {: RESULT=new RegularMethod(I1); RESULT.setLine(I1left); :}
               |
               (MainMethod)MAIN {: RESULT=new MainMethod(); :}
               ;

TypeChoice ::= (NoVoidMethod)IDENT:I1 {: RESULT=new NoVoidMethod(I1); RESULT.setLine(I1left); :}
               |
               (VoidMethod)VOID {: RESULT=new VoidMethod(); :}
               ;

FormParsOptional ::=  FormPars:F1 {: RESULT=new FormParsOptionalDerived1(F1); RESULT.setLine(F1left); :}
                      |
                      MethodSignatureEndFormPars:M1 {: RESULT=new FormParsOptionalDerived2(M1); RESULT.setLine(M1left); :} /* epsilon */
                      ;

MethodDecl ::= (MethodDecl)MethodSignature:M1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDecl(M1, V2, S3); RESULT.setLine(M1left); :}
               ;

VarDeclList ::= VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
                | {: RESULT=new VarDeclListDerived2(); :}
                /* epsilon */
                ;

FormPars ::= Type:T1 VarDeclFinal:V2 MethodSignatureEndFormPars:M3 {: RESULT=new FormParsDerived1(T1, V2, M3); RESULT.setLine(T1left); :}
             |
             error MethodSignatureEndFormPars:l
             {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :} {: RESULT=new FormParsDerived2(l); RESULT.setLine(lleft); :}
             |
             Type:T1 VarDeclFinal:V2 COMMA FormPars:F3 {: RESULT=new FormParsDerived3(T1, V2, F3); RESULT.setLine(T1left); :}
             |
             VarDeclErrorComma:V1 FormPars:F2 {: RESULT=new FormParsDerived4(V1, F2); RESULT.setLine(V1left); :}
             ;

Type ::= (TypeIdent) IDENT:I1 {: RESULT=new TypeIdent(I1); RESULT.setLine(I1left); :}
         |
         (TypeSet) SET {: RESULT=new TypeSet(); :}
         ;

StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
                  | {: RESULT=new StatementListDerived2(); :}
                  /* epsilon */
                  ;

Statement ::=   DesignatorStatement:D1 {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
              |
              IF LPAREN StatementCondition:S1 Statement:S2 ELSE Statement:S3 {: RESULT=new StatementDerived2(S1, S2, S3); RESULT.setLine(S1left); :}
              |
              IF LPAREN StatementCondition:S1 Statement:S2 {: RESULT=new StatementDerived3(S1, S2); RESULT.setLine(S1left); :}
              |
              BREAK SEMI {: RESULT=new StatementDerived4(); :}
              |
              CONTINUE SEMI {: RESULT=new StatementDerived5(); :}
              |
              RETURN SEMI {: RESULT=new StatementDerived6(); :}
              |
              RETURN Expr:E1 SEMI {: RESULT=new StatementDerived7(E1); RESULT.setLine(E1left); :}
              |
              READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementDerived8(D1); RESULT.setLine(D1left); :}
              |
              PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StatementDerived9(E1); RESULT.setLine(E1left); :}
              |
              PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new StatementDerived10(E1, N2); RESULT.setLine(E1left); :}
              |
              DO Statement:S1 WHILE LPAREN RPAREN SEMI {: RESULT=new StatementDerived11(S1); RESULT.setLine(S1left); :}
              |
              DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new StatementDerived12(S1, C2); RESULT.setLine(S1left); :}
              |
              DO Statement:S1 WHILE LPAREN Condition:C2 COMMA DesignatorStatementWhile:D3 RPAREN SEMI {: RESULT=new StatementDerived13(S1, C2, D3); RESULT.setLine(S1left); :}
              |
              LBRACE StatementList:S1 RBRACE {: RESULT=new StatementDerived14(S1); RESULT.setLine(S1left); :}
              ;

DesignatorStatementWhile ::= Designator:D1 DesignatorStatementChoice:D2 {: RESULT=new DesignatorStatementWhileDerived1(D1, D2); RESULT.setLine(D1left); :}
                        |
                        DesignatorAssignWhile:D1 {: RESULT=new DesignatorStatementWhileDerived2(D1); RESULT.setLine(D1left); :}
                        ;

DesignatorAssignWhile ::= Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorAssignWhileDerived1(D1, A2, E3); RESULT.setLine(D1left); :}
                          |
                          Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 {: RESULT=new DesignatorAssignWhileDerived2(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
                          ;

StatementCondition ::= Condition:C1 RPAREN {: RESULT=new StatementConditionDerived1(C1); RESULT.setLine(C1left); :}
                       |
                       error RPAREN:l
                       {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :} {: RESULT=new StatementConditionDerived2(); :}
                       ;


DesignatorStatement ::= Designator:D1 DesignatorStatementChoice:D2 SEMI {: RESULT=new DesignatorStatementDerived1(D1, D2); RESULT.setLine(D1left); :}
                        |
                        DesignatorAssign:D1 {: RESULT=new DesignatorStatementDerived2(D1); RESULT.setLine(D1left); :}
                        ;

DesignatorAssign ::= Designator:D1 Assignop:A2 Expr:E3 SEMI {: RESULT=new DesignatorAssignDerived1(D1, A2, E3); RESULT.setLine(D1left); :}
                     |
                     Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 SEMI {: RESULT=new DesignatorAssignDerived2(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
                     |
                     error SEMI:l
                     {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new DesignatorAssignDerived3(); :}
                     ;

DesignatorStatementChoice ::= LPAREN ActPars:A1 RPAREN {: RESULT=new DesignatorStatementChoiceDerived1(A1); RESULT.setLine(A1left); :}
                              |
                              LPAREN RPAREN {: RESULT=new DesignatorStatementChoiceDerived2(); :}
                              |
                              INC {: RESULT=new DesignatorStatementChoiceDerived3(); :}
                              |
                              DEC {: RESULT=new DesignatorStatementChoiceDerived4(); :}
                              ;

Designator ::= IDENT:I1 DesignatorList:D2 {: RESULT=new DesignatorDerived1(I1, D2); RESULT.setLine(I1left); :}
               ;

DesignatorList ::= DesignatorList:D1 DesignatorListElem:D2 {: RESULT=new DesignatorListDerived1(D1, D2); RESULT.setLine(D1left); :}
                   | {: RESULT=new DesignatorListDerived2(); :}
                   /* epsilon */
                   ;

ActPars ::= Expr:E1 COMMA ActPars:A2 {: RESULT=new ActParsDerived1(E1, A2); RESULT.setLine(E1left); :}
            |
            Expr:E1 {: RESULT=new ActParsDerived2(E1); RESULT.setLine(E1left); :}
            ;

Condition ::= CondTerm:C1 ConditionList:C2 {: RESULT=new ConditionDerived1(C1, C2); RESULT.setLine(C1left); :}
              ;

ConditionList ::= ConditionList:C1 OR CondTerm:C2 {: RESULT=new ConditionListDerived1(C1, C2); RESULT.setLine(C1left); :}
                  | {: RESULT=new ConditionListDerived2(); :}
                  /* epsilon */
                  ;

CondTerm ::= CondFact:C1 CondFactList:C2 {: RESULT=new CondTermDerived1(C1, C2); RESULT.setLine(C1left); :}
             ;

CondFactList ::= CondFactList:C1 AND CondFact:C2 {: RESULT=new CondFactListDerived1(C1, C2); RESULT.setLine(C1left); :}
                 | {: RESULT=new CondFactListDerived2(); :}
                 /* epsilon */
                 ;

CondFact ::= Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFactDerived1(E1, R2, E3); RESULT.setLine(E1left); :}
             |
             Expr:E1 {: RESULT=new CondFactDerived2(E1); RESULT.setLine(E1left); :}
             ;

Expr ::= (ExprTerm) Term:T1 {: RESULT=new ExprTerm(T1); RESULT.setLine(T1left); :}
         |
         (ExprMinusTerm) MINUS Term:T1 {: RESULT=new ExprMinusTerm(T1); RESULT.setLine(T1left); :}
         |
         (ExprAddopTerm) Expr:E1 Addop:A2 Term:T3 {: RESULT=new ExprAddopTerm(E1, A2, T3); RESULT.setLine(E1left); :}
         |
         Designator:D1 MapDesignator:M2 {: RESULT=new ExprDerived1(D1, M2); RESULT.setLine(D1left); :}
         ;

MapDesignator ::= MAP Designator:D1 {: RESULT=new MapDesignatorDerived1(D1); RESULT.setLine(D1left); :}
                  ;

Term ::= (TermFactor) Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :}
         |
         (TermTermMulopFactor) Term:T1 Mulop:M2 Factor:F3 {: RESULT=new TermTermMulopFactor(T1, M2, F3); RESULT.setLine(T1left); :}
         ;

Factor ::= Designator:D1 FactorOptional:F2 {: RESULT=new FactorDerived1(D1, F2); RESULT.setLine(D1left); :}
           |
           (FactorConstDeclListValue) ConstDeclListValue:C1 {: RESULT=new FactorConstDeclListValue(C1); RESULT.setLine(C1left); :}
           |
           NEW Type:T1 FactorChoice:F2 {: RESULT=new FactorDerived2(T1, F2); RESULT.setLine(T1left); :}
           |
           LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived3(E1); RESULT.setLine(E1left); :}
           ;

FactorChoice ::= LBRACKET Expr:E1 RBRACKET {: RESULT=new FactorChoiceDerived1(E1); RESULT.setLine(E1left); :}
                 |
                 LPAREN ActPars:A1 RPAREN {: RESULT=new FactorChoiceDerived2(A1); RESULT.setLine(A1left); :}
                 |
                 LPAREN RPAREN {: RESULT=new FactorChoiceDerived3(); :}
                 ;

FactorOptional ::= LPAREN RPAREN {: RESULT=new FactorOptionalDerived1(); :}
                   |
                   LPAREN ActPars:A1 RPAREN {: RESULT=new FactorOptionalDerived2(A1); RESULT.setLine(A1left); :}
                   | {: RESULT=new FactorOptionalDerived3(); :}
                   /* epsilon */
                   ;

DesignatorListElem ::= DOT IDENT:I1 {: RESULT=new DesignatorListElemDerived1(I1); RESULT.setLine(I1left); :}
                       |
                       LBRACKET Expr:E1 RBRACKET {: RESULT=new DesignatorListElemDerived2(E1); RESULT.setLine(E1left); :}
                       ;

Label ::= IDENT:I1 {: RESULT=new LabelDerived1(I1); RESULT.setLine(I1left); :} ;

Assignop ::= EQ {: RESULT=new AssignopDerived1(); :} ;

Relop ::= EQEQ {: RESULT=new RelopDerived1(); :} | NOTEQ {: RESULT=new RelopDerived2(); :} | GR {: RESULT=new RelopDerived3(); :} | GREQ {: RESULT=new RelopDerived4(); :} | LE {: RESULT=new RelopDerived5(); :} | LEQ {: RESULT=new RelopDerived6(); :} ;

Addop ::= PLUS {: RESULT=new AddopDerived1(); :} | MINUS {: RESULT=new AddopDerived2(); :} ;

Mulop ::= MUL {: RESULT=new MulopDerived1(); :} | DIV {: RESULT=new MulopDerived2(); :} | MOD {: RESULT=new MulopDerived3(); :} ;

Setop ::= UNION {: RESULT=new SetopDerived1(); :} ;
